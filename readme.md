##  网络同步盘的设计与实现 

- 网盘（网络 U 盘、网络硬盘）因为其便捷性被很多人青睐（目前国内多家网盘运营商停止服务，不是技术问题，而是管理与盈利问题，与本次作业无关，本次作业只讨论技术性问题），一个便捷的网盘服务，可以跨平台、跨地域，实现文件的存储、共享等功能；不需要随身携带存储介质，只要能上网，就能访问文件。 

- 网络同步盘是网盘的功能之一，具体形式为：机器上运行网络同步盘的客户端，在网盘上指定一个目录、本机上指定一个目录，两者绑定之后，将文件拖入本机目录，就会自动上传到网盘的指定目录下，如果用户再在另一台机器上运行网络同步盘的客户端并以同一账号登录，则网盘同步盘的文件会即时更新到另一台机器的本地目录中。 

***

#### 实现的功能

- 网盘的服务器操作系统确定为 CentOS 8，数据库系统使用 CentOS 8 自带的 MariaDB 10，编程语

  言为 C/C++，字符集为 GBK/GB18030 

#### 基本功能

- 新用户的注册，要求可以自定义用户名和密码，检查用户名是否重复

- 已有用户的登录，通过验证用户名和密码，允许合法的用户登录

- 用户名和密码在传输过程中不必考虑加密问题（即抓包可看到明文），但对密码的长度和强

  度要有一定要求，服务器上存储的密码必须是加密形式

- 用户登录成功后，可以看到自己账户下网盘的目录结构（允许为每个新用户定义一个初始

  目录结构，下含若干目录）

- 可以指定目录结构中的某个目录为同步目录，同步目录要允许更换
- 可以将本机上的某个目录与服务端指定的同步目录绑定/解绑，允许更换本机目录
- 客户端应该能看到同步过程的各种信息（日志）

#### 单机同步初始化

- 如果服务器的目录下有文件，要全部下载到本机的目录下

- 如果本机的目录下有文件，要全部上传到服务器目录下

- 服务器上的文件，如果内容相同（以 MD5 码/SHA 码的计算值为准），则真实文件**只允许**保留

  一份，然后产生两个链接（服务器上真实文件的命名规则可自行定义），因此相同文件向服

  务器的上传要做到“秒传”（例：本机的 CentOS8.iso 文件，已同步到服务器上，再复制一

  份为 CentOS8-dual.iso，则服务器秒传）

- 如果服务器目录下的文件和本机目录下的文件名相同且内容相同（以 MD5 码/SHA 码的计算

  值为准），则**不允许**再次上传/下载，要做到“秒同步”

- 如果服务器目录下的文件和本机目录下的文件名不同但内容相同（以 MD5 码/SHA 码的计算

  值为准），则以服务器上的文件名为准更改本机文件名

- 如果服务器目录下的文件和本机目录下的文件名相同但内容不同（以 MD5 码/SHA 码的计算

  值为准），则最终应该有两个文件

- 本机目录/服务器目录均可能包含下级子目录
- 初始同步完成后，本机和服务器对应目录的内容保持一致

#### 单机与服务端在初始同步完成后的同步规则（假设客户端始终在运行）

- 如果在本机目录下删除文件，则服务器对应删除（考虑服务器上该真实文件还有其它链

  接存在，无其它链接存在等情况）

- 如果在本机目录下删除下级子目录，则服务器对应删除 
- 在客户端运行时，除非解除绑定，**不允许**删除本机目录，如果本机目录不存在/在客户端未运行或解除绑定后被删除，则需要重新建立本机目录，按初始同步规则进行 
- 如果在本机上增加文件/子目录，则服务器对应增加 
- 如果在本机上修改文件名/子目录名，则服务器对应修改 
- **不需要**考虑直接在服务端增加文件

#### 多机（多个客户端在不同机器上以相同用户名登录）文件的同步规则

- 按两个单机-服务端的同步规则进行处理，服务端要考虑同步顺序的控制以避免冲突 
  - 如果 A机的 test1.dat与 B机的 test2.dat文件内容相同，同步后的命名规则应如何？ 
  - 如果 A 机和 B 机同时增加新文件 new.dat，但内容不同，应如何处理？ 
- A 机上删除文件/子目录后，B 机同步删除 
- A 机上增加文件/子目录后，B 机同步增加 
- A 机上文件/子目录改名后，B 机同步更改 
- 如果 A 机/B 机上有内容相同（MD5 码/SHA 码的值相同）的文件要同步到服务器上，可以选择先将某台机器的文件同步，完成后另外一台机器再“秒同步” 

***

#### 重点设计

**传输协议格式** 

（1）约定实地址为用户端地址，虚地址为服务器端地址，以下请求地址默认为实地址 

（2）请求类型等等只占一个字节，下面为了表示方便所以写成字符串 

（3）传输的原则是，一次请求对应一次回复。得到回复之后请求就结束。至于请求之间的逻辑关系是服务器和客户端自行负责。例如传输文件分为两步，第一步客户端向服务器发送传输文件请求，服务器给予答复（允许传输或者不允许传输）；第二步服务器向客户端索取文件，客户端传输。 

（4）{}表示一项，实际传输中会进行压缩

（5）项分为可变长度和不变长度，不变长度放在前面，这样可以用 struct 很方便地读取出不变的项目，并且可变长度项的长度也会被包含在内，所以根据这些长度读取剩下的内容即可。例如新增文件可以写成类似如下格式： 

```c++
struct acquire 
{ 
    int id; 
    int type; 
    char file_md5[32]; 
    int startpos; 
    int endpos; 
    int contentlen; 
};
```

1、删除文件 

请求：“{id} {delete} {addr_len}{file_addr}” 

回复：{id}{status} （status:删除成功、暂时无法删除、删除失败） 

2、 新增文件(只发送文件信息，此时需要打开，直到文件传输完成或者通知不需要传输文 

件) 

请求：“{id}{add}{file_md5}{file_time}{addr_len}{file_addr}” 

回复：{id}{status} （status:允许新增、暂时无法新增、无需新增） 

3、传输文件（真正进行文件传输） 

请求：“{id}{acquire}{file_md5}{start_pos}{end_pos}{addr_len}{file_addr}” 

回复：{id}{status}{start_pos}{end_pos}{content}文件传输内容包 

4、 修改文件（夹）名 

请求：“{id}{modify}{addr_len}{name_len}{file_addr}{file_name}” 

回复：“{id}{status}”(修改成功、失败、暂时无法修改) 

5、打印目录结构，该目录为虚目录 

请求：“{id}{print}{depth}{addr_len}{file_addr}” 

回复：“{id}{status}{tree_len}{tree}” 

6、注册 

请求：“{id}{register}{passwd_len}{name_len}{user_passwd} {user_name}”

回复：“{id}{status}” 成功、失败（包括失败原因） 

7、登录 

请求：“{id}{login}{count_len}{user_count}{user_passwd}” 

回复：“{id}{status}” 

登录后在服务端创建“socket”——“用户 id”的哈希表



**路径解析** 

- 在服务器和客户端交互过程中，客户端的实地址需要转化为服务器的虚地址才能在服务 器上存储，反之亦然。由于共享目录下的普通文件和文件夹两端是一致的，因此只需要对共享目录进行转化即可。可以建立一棵实地址共享文件夹的树，叶子节点存储虚地址，因而当读入一个实地址的时候，就根据实地址从树根开始移动，移动到叶子节点便将对应实地址改为虚地址即可。反之亦然。

  

**存储方案设计** 

- 如上面数据库所设计的那样，我们将会把用户的目录和文件以邻接表方式存入数据库中， 其中文件实际上只是一个虚文件，只是一个指向真实文件的连接（如同软连接一样，不过软 连接的方式我们经过仔细考虑认为其速度太慢放弃了）。 

- 而所有用户的真实文件我们将会保存在服务器的一个指定位置上，并且就以文件的 MD5 码命名，由于 MD5 码是区分文件的唯一标志（在本问题中），因而这样不会出现冲突。 然后在数据库中记录该文件以及指向该文件的链接数，为 0 的时候理论上可以删除该文件 （无紧急情况会保留，以防止后面会再次恢复）

  

**用户目录结构设计** 

- 用户目录是由上面的两张表构成，一张记录了服务器和客户端的共享文件夹对应关系， 并记录了这一对应关系是否绑定。通过这张表并配合虚实路径转换树（上文中的路径解析） 即可将客户端路径转化为虚路径（用户目录和用户文件），在服务器上以邻接表的方式存储 该虚目录和虚文件即可。

  

**实现断点续传和分块传输** 

- 上 文 中 谁 需 要 文 件 谁 发 送 request 请 求 ， 并 且 request 只 请 求 传 输 该 文 件 的 [start_pos,end_pos)范围内的字节。因此这个方法可以用于实现分块传输和断点续传。 

- 每接受指定长度的字节（8K）那么就会发生一次写入磁盘文件，此时传输未完成，并且随时可能被打断，所以要同时更新当前已经传输了多少字节，并且写入磁盘文件或者数据库。一旦发生突发情况，那么重新连接上去的时候根据这些未传输完毕的文件信息即可实现断点续传。

